Matt's implementation notes.
-----------------------------

2009-JUL-10
============

Development is mostly test-driven.
So I'm writing unit tests first for all the things that needs to function as expected.

The first important part I finished is reading/writing transformations.
Then I created a workaround for a few problem with Locking.  
  - Session specific problems : locks didn't survive a session
  - Couldn't figure out a way to add lock dates, lock message or other future attributes
  - This was solved by the creation of a new root level locking node where all the locks are stored in.  The name of the node is the GUID against the locked object.  
Then I did database metadata.

There I had the interesting challenge of creating objects that can cope with a rename.
That was solved in the past by having the various steps and job entries that reference a database use a Repository method:
  
  	public void saveDatabaseMetaStepAttribute(ObjectId id_transformation, ObjectId id_step, String code, DatabaseMeta database) throws KettleException;
  	public void saveDatabaseMetaJobEntryAttribute(ObjectId id_job, ObjectId id_jobentry, String code, DatabaseMeta database) throws KettleException;
  
Now, typically you save the ID of the database in there.  The classic Kettle database repository then has a link table R_TRANS_DATABASE that keeps track of all the transformation-databases relationships.
The JCR has something better, it can save references.  It took me a while to figure that out but this is the best solution.
Once this gnarly problem was out of the way I could delete the other trial code (using ID/ID relationship usage nodes).

Initially I simply stored XML in the nodes but that's not an ideal solution.
The thing is that things like Names and descriptions of PDI objects needs to be stored as attributes anyway if we want to get at them quickly.
So I borrowed some code from the existing repository to save things into Node Properties all the time.
This conversion is still going on but progressing nicely and brings me to the PartitionSchema objects (also a shared object).
I basically had the same problems as with the DatabaseMeta objects so I'm converting that too.

Finished are:
- Creating / Deleting directories
- Saving / Loading transformations
- Creating / loading transformation versions
- Retrieval of a list of versions
- Retrieval of object IDs, optionally list deleted ones
- Deleting / restoring transformations
- Verify existence of a transformation
- Rename of a database connection (without consequence for the transformation)

TODO are:
- Finish PartitionSchema save/load conversion to Node Properties
- Save/Load SlaveServer
- ClusterSchema
- Make sure that logging database information is also references, not stored.
- Jobs and job entries

Fortunately those are easier now that the hard problems around the versioning of data are solved and tested.


2009-JUL-14
============

Finished are:
- Creating / Deleting directories
- Saving / Loading transformations
- Creating / loading transformation versions
- Retrieval of a list of versions
- Retrieval of object IDs, optionally list deleted ones
- Deleting / restoring transformations
- Verify existence of a transformation
- Rename of a database connection (without consequence for the transformation)
- Save/Load/Delete/Rename SlaveServer
- Save/Load/Delete/Rename ClusterSchema
- Save/Load/Delete/Rename PartitionSchema
- Make sure that logging database information is also references, not stored.
- Rename/move of transformation
- Rename of directory 

TODO:
- Adding more unit tests to test rename/delete and delete of used objects (finer points)
- Jobs and job entries

2009-JUL-17
============
The finer points of loading/saving transformations, versioning, loading versions, deleting, moving was tested through.
I also created a basic version browser dialog, dynamically loaded from the repository plugin.

Sent a mail to users@jackrabbit mailing list to ask clarification on version numbering schema "1.0" --> "1.1" --> "1.N" where 1 is always 1.
I'm pondering removing the "1." part from the version name in PDI.

It would be cool to have a general versioning system that you can maintain like we have in JIRA.
So we would define a number of general version labels like 1.0-M1, 1.0-M2, 1.0-M3, etc.
This could be applied as a blanket application to the last versions of all objects in the repository or against individual objects during save/commit.  

2009-AUG-06
============

After long consideration, I'm changing the term "Object Version" to "Object Revision".
This is a more correct naming.  Later we can create a version catalog.


 
